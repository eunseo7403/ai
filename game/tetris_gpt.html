<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris (HTML/CSS/JS)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#121a2b;
      --text:#e6e9f2;
      --muted:#9aa3b2;
      --line:#23304a;
      --btn:#1f2b44;
      --btnHover:#2a3a5c;
      --danger:#ff5a5f;
      --ok:#4ad295;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;
      background:radial-gradient(1200px 800px at 30% 20%, #162043 0%, var(--bg) 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .wrap{
      display:grid;
      grid-template-columns:auto 280px;
      gap:18px;
      align-items:start;
      max-width: 980px;
      width:100%;
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.03) 100%);
      border:1px solid rgba(255,255,255,0.08);
      border-radius:14px;
      box-shadow:0 12px 40px rgba(0,0,0,0.35);
      padding:16px;
    }
    .boardCard{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .title{
      font-weight:800;
      letter-spacing:0.2px;
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .title small{
      font-weight:600;
      color:var(--muted);
    }
    canvas{
      background:linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.35));
      border:1px solid rgba(255,255,255,0.08);
      border-radius:12px;
      display:block;
      width: 360px;
      height: 720px;
      image-rendering: pixelated;
    }
    .side{
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .stat{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:center;
      padding:12px;
      border-radius:12px;
      background:rgba(0,0,0,0.18);
      border:1px solid rgba(255,255,255,0.06);
    }
    .stat div:nth-child(odd){
      color:var(--muted);
      font-weight:600;
      font-size:13px;
    }
    .stat div:nth-child(even){
      font-weight:800;
    }
    .mini{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .mini canvas{
      width: 120px;
      height: 120px;
      border-radius:12px;
    }
    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,0.10);
      background:var(--btn);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:800;
      transition:0.15s ease;
      flex:1 1 auto;
      min-width:120px;
    }
    button:hover{ background:var(--btnHover); }
    button:active{ transform: translateY(1px); }
    .primary{
      border-color: rgba(74,210,149,0.35);
      box-shadow:0 0 0 1px rgba(74,210,149,0.15) inset;
    }
    .danger{
      border-color: rgba(255,90,95,0.35);
      box-shadow:0 0 0 1px rgba(255,90,95,0.15) inset;
    }
    .hint{
      padding:12px;
      border-radius:12px;
      background:rgba(0,0,0,0.18);
      border:1px solid rgba(255,255,255,0.06);
      color:var(--muted);
      font-size:13px;
      line-height:1.5;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(0,0,0,0.15);
      color:var(--muted);
      font-weight:800;
      font-size:12px;
    }
    .statusRow{
      display:flex;
      align-items:center;
      gap:8px;
      justify-content:flex-end;
    }
    .statusDot{
      width:8px;height:8px;border-radius:50%;
      background:var(--ok);
      box-shadow:0 0 0 3px rgba(74,210,149,0.18);
    }
    .statusDot.off{
      background:var(--danger);
      box-shadow:0 0 0 3px rgba(255,90,95,0.18);
    }
    .overlay{
      position:relative;
    }
    .overlayMsg{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:18px;
      border-radius:12px;
      background:rgba(0,0,0,0.60);
      border:1px solid rgba(255,255,255,0.10);
      opacity:0;
      pointer-events:none;
      transition:0.2s ease;
    }
    .overlayMsg.show{
      opacity:1;
      pointer-events:auto;
    }
    .overlayMsg h2{
      margin:0 0 8px;
      font-size:22px;
      letter-spacing:0.2px;
    }
    .overlayMsg p{
      margin:0;
      color:var(--muted);
      font-weight:600;
      line-height:1.5;
    }
    @media (max-width: 820px){
      .wrap{ grid-template-columns:1fr; }
      canvas{ width:100%; height:auto; aspect-ratio: 1/2; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card boardCard">
      <div class="topbar">
        <div class="title">Tetris <small>HTML/CSS/JS</small></div>
        <div class="statusRow">
          <span class="badge" id="stateBadge">
            <span class="statusDot" id="stateDot"></span>
            <span id="stateText">RUNNING</span>
          </span>
        </div>
      </div>

      <div class="overlay">
        <canvas id="game" width="300" height="600" aria-label="tetris board"></canvas>
        <div class="overlayMsg" id="overlay">
          <div>
            <h2 id="overlayTitle">GAME OVER</h2>
            <p id="overlayDesc">재시작 버튼을 눌러 다시 시작할 수 있어요.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="side">
      <div class="card">
        <div class="mini">
          <div>
            <div style="font-weight:900;margin-bottom:8px;">NEXT</div>
            <canvas id="next" width="120" height="120"></canvas>
          </div>
          <div style="flex:1">
            <div class="stat">
              <div>점수</div><div id="score">0</div>
              <div>레벨</div><div id="level">1</div>
              <div>라인</div><div id="lines">0</div>
              <div>속도(ms)</div><div id="speed">700</div>
            </div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="btns">
          <button class="primary" id="restartBtn">재시작</button>
          <button id="pauseBtn">일시정지(P)</button>
          <button class="danger" id="hardDropBtn">하드드롭(Space)</button>
        </div>

        <div style="height:10px"></div>

        <div class="hint">
          <b>조작</b><br/>
          ← → : 이동 / ↓ : 소프트드롭 / ↑ : 회전 / Space : 하드드롭 / P : 일시정지<br/>
          <span style="display:inline-block;margin-top:6px;">
            <b>팁</b> 라인이 지워질수록 레벨이 올라가고 속도가 빨라집니다.
          </span>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  // ===== UI =====
  const elScore = document.getElementById('score');
  const elLevel = document.getElementById('level');
  const elLines = document.getElementById('lines');
  const elSpeed = document.getElementById('speed');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayDesc = document.getElementById('overlayDesc');

  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const hardDropBtn = document.getElementById('hardDropBtn');

  const stateText = document.getElementById('stateText');
  const stateDot = document.getElementById('stateDot');

  // ===== Game Constants =====
  const COLS = 10;
  const ROWS = 20;
  const BLOCK = 30; // canvas: 300x600 => 10*30 x 20*30

  const COLORS = {
    I: '#4fd1c5',
    O: '#f6e05e',
    T: '#b794f4',
    S: '#68d391',
    Z: '#fc8181',
    J: '#63b3ed',
    L: '#f6ad55',
    G: '#101827' // ghost
  };

  // 4x4 matrices for pieces
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0]
    ]
  };

  const PIECES = Object.keys(SHAPES);

  // ===== State =====
  let board;
  let cur, next;
  let score, lines, level;
  let dropInterval;     // ms
  let dropCounter = 0;  // ms
  let lastTime = 0;
  let running = false;
  let paused = false;
  let gameOver = false;

  // ===== Helpers =====
  const cloneMatrix = (m) => m.map(row => row.slice());

  function emptyBoard(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(null));
  }

  function randomPiece(){
    const type = PIECES[Math.floor(Math.random()*PIECES.length)];
    return {
      type,
      matrix: cloneMatrix(SHAPES[type]),
      x: 3,
      y: -1
    };
  }

  function rotate(matrix){
    // 4x4 rotate CW
    const N = matrix.length;
    const res = Array.from({length:N}, () => Array(N).fill(0));
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        res[x][N-1-y] = matrix[y][x];
      }
    }
    return res;
  }

  function collide(b, piece){
    const m = piece.matrix;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = piece.x + x;
        const by = piece.y + y;
        if(bx < 0 || bx >= COLS || by >= ROWS) return true;
        if(by >= 0 && b[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(b, piece){
    const m = piece.matrix;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = piece.x + x;
        const by = piece.y + y;
        if(by >= 0) b[by][bx] = piece.type;
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){
        if(!board[y][x]) continue outer;
      }
      // full row
      board.splice(y,1);
      board.unshift(Array(COLS).fill(null));
      cleared++;
      y++; // re-check same index after unshift
    }

    if(cleared > 0){
      lines += cleared;
      // scoring (classic-ish)
      const base = [0, 100, 300, 500, 800][cleared] || (cleared*250);
      score += base * level;

      // level up each 10 lines
      const newLevel = Math.floor(lines/10) + 1;
      if(newLevel !== level){
        level = newLevel;
        // speed up (lower interval), clamp
        dropInterval = Math.max(120, 700 - (level-1)*60);
      }
      updateUI();
    }
  }

  function updateUI(){
    elScore.textContent = String(score);
    elLines.textContent = String(lines);
    elLevel.textContent = String(level);
    elSpeed.textContent = String(dropInterval);
  }

  function setBadge(){
    if(gameOver){
      stateText.textContent = 'GAME OVER';
      stateDot.classList.add('off');
      return;
    }
    if(paused){
      stateText.textContent = 'PAUSED';
      stateDot.classList.add('off');
      return;
    }
    stateText.textContent = 'RUNNING';
    stateDot.classList.remove('off');
  }

  function showOverlay(title, desc){
    overlayTitle.textContent = title;
    overlayDesc.textContent = desc;
    overlay.classList.add('show');
  }
  function hideOverlay(){
    overlay.classList.remove('show');
  }

  // ===== Drawing =====
  function drawCell(x,y,color, context=ctx, size=BLOCK){
    context.fillStyle = color;
    context.fillRect(x*size, y*size, size, size);

    // subtle grid line
    context.strokeStyle = 'rgba(255,255,255,0.08)';
    context.strokeRect(x*size+0.5, y*size+0.5, size-1, size-1);

    // highlight
    context.fillStyle = 'rgba(255,255,255,0.10)';
    context.fillRect(x*size, y*size, size, Math.max(2, size*0.12));
  }

  function drawBoard(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // grid background
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    for(let x=0;x<=COLS;x++){
      ctx.beginPath();
      ctx.moveTo(x*BLOCK+0.5,0);
      ctx.lineTo(x*BLOCK+0.5,canvas.height);
      ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      ctx.beginPath();
      ctx.moveTo(0,y*BLOCK+0.5);
      ctx.lineTo(canvas.width,y*BLOCK+0.5);
      ctx.stroke();
    }

    // fixed blocks
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const t = board[y][x];
        if(t) drawCell(x,y,COLORS[t]);
      }
    }
  }

  function drawPiece(piece, ghost=false){
    const m = piece.matrix;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(!m[y][x]) continue;
        const bx = piece.x + x;
        const by = piece.y + y;
        if(by < 0) continue;
        if(ghost){
          // ghost: transparent fill
          ctx.save();
          ctx.globalAlpha = 0.25;
          drawCell(bx, by, '#cbd5e1');
          ctx.restore();
        } else {
          drawCell(bx, by, COLORS[piece.type]);
        }
      }
    }
  }

  function getGhost(piece){
    const g = { ...piece, matrix: piece.matrix.map(r=>r.slice()) };
    while(!collide(board, { ...g, y: g.y+1 })) g.y++;
    return g;
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    // draw in a 4x4 grid, size 24 => 96, center inside 120
    const size = 24;
    const offsetX = Math.floor((nextCanvas.width - 4*size)/2);
    const offsetY = Math.floor((nextCanvas.height - 4*size)/2);

    // bg grid
    nctx.strokeStyle = 'rgba(255,255,255,0.08)';
    for(let i=0;i<=4;i++){
      nctx.beginPath();
      nctx.moveTo(offsetX + i*size + 0.5, offsetY);
      nctx.lineTo(offsetX + i*size + 0.5, offsetY + 4*size);
      nctx.stroke();
      nctx.beginPath();
      nctx.moveTo(offsetX, offsetY + i*size + 0.5);
      nctx.lineTo(offsetX + 4*size, offsetY + i*size + 0.5);
      nctx.stroke();
    }

    const m = next.matrix;
    for(let y=0;y<4;y++){
      for(let x=0;x<4;x++){
        if(!m[y][x]) continue;
        const px = offsetX + x*size;
        const py = offsetY + y*size;

        nctx.fillStyle = COLORS[next.type];
        nctx.fillRect(px, py, size, size);
        nctx.strokeStyle = 'rgba(255,255,255,0.12)';
        nctx.strokeRect(px+0.5, py+0.5, size-1, size-1);
        nctx.fillStyle = 'rgba(255,255,255,0.12)';
        nctx.fillRect(px, py, size, Math.max(2, size*0.18));
      }
    }
  }

  function render(){
    drawBoard();
    const ghost = getGhost(cur);
    drawPiece(ghost, true);
    drawPiece(cur, false);
  }

  // ===== Game Loop =====
  function update(time=0){
    if(!running) return;

    const delta = time - lastTime;
    lastTime = time;

    if(!paused && !gameOver){
      dropCounter += delta;
      if(dropCounter >= dropInterval){
        softDrop();
        dropCounter = 0;
      }
      render();
    }

    requestAnimationFrame(update);
  }

  // ===== Actions =====
  function spawn(){
    cur = next;
    cur.x = 3;
    cur.y = -1;
    next = randomPiece();
    drawNext();

    // game over check
    if(collide(board, cur)){
      endGame();
    }
  }

  function endGame(){
    gameOver = true;
    running = true; // keep loop for overlay
    paused = false;
    setBadge();
    showOverlay('GAME OVER', '재시작 버튼을 눌러 다시 시작할 수 있어요.');
    render();
  }

  function move(dir){
    if(paused || gameOver) return;
    const p = { ...cur, x: cur.x + dir };
    if(!collide(board, p)){
      cur.x += dir;
      render();
    }
  }

  function softDrop(){
    if(paused || gameOver) return;
    const p = { ...cur, y: cur.y + 1 };
    if(!collide(board, p)){
      cur.y++;
    } else {
      // lock
      merge(board, cur);
      clearLines();
      spawn();
    }
  }

  function hardDrop(){
    if(paused || gameOver) return;
    while(!collide(board, { ...cur, y: cur.y + 1 })){
      cur.y++;
      score += 2; // small bonus per cell
    }
    // lock
    merge(board, cur);
    clearLines();
    spawn();
    updateUI();
    render();
  }

  function rotateCW(){
    if(paused || gameOver) return;
    const rotated = rotate(cur.matrix);
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      const test = { ...cur, matrix: rotated, x: cur.x + k };
      if(!collide(board, test)){
        cur.matrix = rotated;
        cur.x += k;
        render();
        return;
      }
    }
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    setBadge();
    if(paused){
      showOverlay('PAUSED', 'P를 다시 누르거나 일시정지 버튼을 누르면 계속 진행됩니다.');
    } else {
      hideOverlay();
    }
  }

  // ===== Restart (필수 기능) =====
  function restart(){
    // reset state
    board = emptyBoard();
    score = 0;
    lines = 0;
    level = 1;
    dropInterval = 700;
    dropCounter = 0;
    lastTime = 0;

    paused = false;
    gameOver = false;
    running = true;

    next = randomPiece();
    spawn();

    hideOverlay();
    setBadge();
    updateUI();
    render();
  }

  // ===== Input =====
  document.addEventListener('keydown', (e) => {
    const key = e.code;

    if(key === 'KeyP'){
      e.preventDefault();
      togglePause();
      return;
    }

    if(gameOver){
      // 게임오버 후 키 입력은 막고, 재시작 버튼으로만 시작해도 되지만
      // UX 위해 Enter는 재시작으로 허용
      if(key === 'Enter'){
        e.preventDefault();
        restart();
      }
      return;
    }

    if(paused) return;

    if(key === 'ArrowLeft'){ e.preventDefault(); move(-1); }
    else if(key === 'ArrowRight'){ e.preventDefault(); move(1); }
    else if(key === 'ArrowDown'){ e.preventDefault(); softDrop(); score += 1; updateUI(); }
    else if(key === 'ArrowUp'){ e.preventDefault(); rotateCW(); }
    else if(key === 'Space'){ e.preventDefault(); hardDrop(); }
  });

  // ===== Buttons =====
  restartBtn.addEventListener('click', restart);
  pauseBtn.addEventListener('click', togglePause);
  hardDropBtn.addEventListener('click', hardDrop);

  // ===== Start =====
  function init(){
    board = emptyBoard();
    score = 0; lines = 0; level = 1;
    dropInterval = 700;
    paused = false; gameOver = false;
    running = true;

    next = randomPiece();
    spawn();
    updateUI();
    setBadge();
    render();
    requestAnimationFrame(update);
  }

  init();
})();
</script>
</body>
</html>
